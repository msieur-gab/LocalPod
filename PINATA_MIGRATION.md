# Pinata Migration Plan: Sovereign IPFS Storage

**Branch:** `feat/pinata-sovereign-storage`
**Date:** 2025-10-24
**Status:** üü° Planning

---

## Why This Migration?

### Problem with Current Architecture
- Uses Filebase S3 with presigned URLs generated by grant.html
- Requires AWS secret keys to be embedded somewhere (security risk)
- Users don't control their own IPFS pinning
- Contradicts the European tech independence vision

### Solution: User-Controlled IPFS Providers
- Each user brings their own IPFS provider API key
- True data sovereignty: users control their own IPFS pinning
- Portable CIDs: work on any IPFS gateway
- Simpler architecture: no AWS signature complexity
- European-friendly: users can choose providers (Pinata, Scaleway, 4everland, etc.)
- **Provider abstraction layer** for easy extensibility

---

## Provider Abstraction Strategy

### Phase 1: Pinata as Reference Implementation
- Implement Pinata first as the working reference provider
- Design extensible provider interface from day one
- Document provider interface for future implementations

### Phase 2: Add European Providers (Future)
Target providers when APIs are compatible:
- **Scaleway Labs** (French provider - European sovereignty)
- **4everland** (Decentralized storage network)
- **Temporal (TemporalX)** (Enterprise IPFS)

### Provider Interface Design
All providers must implement:
```javascript
class IPFSProvider {
  async upload(jsonData) { /* returns CID */ }
  async download(cid) { /* returns JSON data */ }
  getGatewayUrl(cid) { /* returns public URL */ }
}
```

---

## Architecture Changes

### Before (S3 Presigned URLs)
```
User ‚Üí demo.html ‚Üí grant.html (generates presigned URL using AWS keys)
                 ‚Üì
            simple-service.html (uses presigned URL for 1 hour)
                 ‚Üì
            Filebase S3 ‚Üí IPFS
```

### After (Pinata JWT)
```
User ‚Üí demo.html (stores Pinata JWT)
     ‚Üì
     grant.html (passes JWT via UCAN)
     ‚Üì
     simple-service.html (uses JWT with Pinata API directly)
     ‚Üì
     Pinata ‚Üí IPFS
```

---

## Files to Modify

### 1. `sdk/storage.js` or `sdk/index.js`
**Current State:** Contains S3/AWS Signature V4 code for Filebase
**Changes Needed:**
- [ ] Remove `generatePresignedUploadUrl()` method
- [ ] Remove `generatePresignedDownloadUrl()` method
- [ ] Remove all AWS signature helper functions (hmac, sha256Hex, etc.)
- [ ] Create provider abstraction layer (base class + provider implementations)
- [ ] Implement PinataProvider as reference implementation
- [ ] Keep UCAN generation/validation intact

**New Provider Architecture:**
```javascript
// Base provider interface
class IPFSProvider {
  constructor(config) {
    this.config = config;
  }

  async upload(jsonData) {
    throw new Error('Must implement upload()');
  }

  async download(cid) {
    throw new Error('Must implement download()');
  }

  getGatewayUrl(cid) {
    throw new Error('Must implement getGatewayUrl()');
  }
}

// Pinata implementation
class PinataProvider extends IPFSProvider {
  constructor(config) {
    super(config);
    this.jwt = config.jwt;
    this.gateway = config.gateway || 'gateway.pinata.cloud';
  }

  async upload(jsonData) {
    // Convert JSON to File object
    const blob = new Blob([JSON.stringify(jsonData)], { type: 'application/json' });
    const file = new File([blob], 'data.json');

    const formData = new FormData();
    formData.append('file', file);

    // POST to Pinata
    const response = await fetch('https://uploads.pinata.cloud/v3/files', {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${this.jwt}` },
      body: formData
    });

    if (!response.ok) throw new Error(`Upload failed: ${response.statusText}`);

    const result = await response.json();
    return result.data.cid;
  }

  async download(cid) {
    const url = this.getGatewayUrl(cid);
    const response = await fetch(url);
    if (!response.ok) throw new Error(`Download failed: ${response.statusText}`);
    return await response.json();
  }

  getGatewayUrl(cid) {
    return `https://${this.gateway}/ipfs/${cid}`;
  }
}

// Factory function
function createProvider(providerName, config) {
  switch (providerName) {
    case 'pinata':
      return new PinataProvider(config);
    // Future: case 'scaleway': return new ScalewayProvider(config);
    // Future: case '4everland': return new FourEverLandProvider(config);
    default:
      throw new Error(`Unknown provider: ${providerName}`);
  }
}
```

---

### 2. `demo.html` (Pod Manager)
**Current State:** Manages identity, stores S3 credentials (if any)
**Changes Needed:**
- [ ] Add IPFS provider configuration section to UI
- [ ] Provider selection dropdown (Pinata for now, extensible for future)
- [ ] Input field for provider API key/JWT
- [ ] Optional: custom gateway URL
- [ ] Store provider config encrypted in IndexedDB (alongside identity)
- [ ] Remove any S3/Filebase credential management
- [ ] Add provider-specific help links

**UI Addition:**
```html
<section>
  <h3>üîë IPFS Storage Configuration</h3>

  <label>Provider:</label>
  <select id="ipfs-provider">
    <option value="pinata">Pinata</option>
    <!-- Future: <option value="scaleway">Scaleway Labs</option> -->
    <!-- Future: <option value="4everland">4everland</option> -->
  </select>

  <label>API Key (JWT):</label>
  <input type="password" id="provider-jwt" />

  <label>Gateway URL (optional):</label>
  <input type="text" id="provider-gateway" placeholder="gateway.pinata.cloud" />

  <button id="save-storage-config">Save Configuration</button>

  <div id="provider-help">
    <p class="help">
      Get your free Pinata API key at
      <a href="https://app.pinata.cloud" target="_blank">app.pinata.cloud</a>
    </p>
  </div>
</section>
```

**Storage Schema Update:**
```javascript
// Add to IndexedDB encryption
{
  identity: { ... },
  storage: {
    provider: 'pinata',  // 'pinata' | 'scaleway' | '4everland' (future)
    config: {
      jwt: 'encrypted_jwt_here',
      gateway: 'gateway.pinata.cloud'  // optional, provider-specific
    }
  }
}
```

---

### 3. `grant.html` (Authorization Flow)
**Current State:** Generates presigned URLs using S3 credentials
**Changes Needed:**
- [ ] Remove `generatePresignedUploadUrl()` call
- [ ] Remove `generatePresignedDownloadUrl()` call
- [ ] Retrieve storage provider config from IndexedDB (user's pod)
- [ ] Pass provider config in grant payload instead of presigned URLs
- [ ] Update UCAN to include storage provider info in facts

**Grant Payload Before:**
```javascript
{
  grantApproved: true,
  ucan: ucanToken,
  presignedUploadUrl: { url: '...', method: 'PUT', ... },
  presignedDownloadUrl: { url: '...', method: 'GET', ... },
  userPublicKey: '...',
  ...
}
```

**Grant Payload After:**
```javascript
{
  grantApproved: true,
  ucan: ucanToken,
  storageProvider: {
    provider: 'pinata',  // provider name
    config: {
      jwt: 'user_provider_jwt_here',
      gateway: 'gateway.pinata.cloud'
    }
  },
  userPublicKey: '...',
  ...
}
```

---

### 4. `simple-service.html` (Example Service)
**Current State:** Uses presigned URLs for upload/download
**Changes Needed:**
- [ ] Remove presigned URL state management
- [ ] Remove presigned URL renewal logic
- [ ] Add storage provider config to state
- [ ] Use SDK's provider abstraction (import createProvider)
- [ ] Update `saveItem()` to use provider.upload()
- [ ] Update `loadData()` to use provider.download()
- [ ] Remove dependency on `renew-presigned-url.html`

**State Before:**
```javascript
let state = {
  ucanToken: null,
  presignedUploadUrl: null,
  presignedDownloadUrl: null,
  userPublicKey: null,
  ipfsCid: null,
  items: []
};
```

**State After:**
```javascript
let state = {
  ucanToken: null,
  storageProvider: null,  // Will be IPFSProvider instance
  userPublicKey: null,
  ipfsCid: null,
  items: []
};
```

**Initialization (handle grant callback):**
```javascript
import { createProvider } from './sdk/index.js';

async function handleGrantCallback(params) {
  const grant = JSON.parse(decodeURIComponent(params.get('grant')));

  // Create provider instance
  state.storageProvider = createProvider(
    grant.storageProvider.provider,
    grant.storageProvider.config
  );

  state.ucanToken = grant.ucan;
  state.userPublicKey = grant.userPublicKey;

  // Save to localStorage
  // ...
}
```

**Upload Logic (simplified):**
```javascript
async function saveItem() {
  // ... prepare data ...

  const data = {
    items: state.items,
    updatedAt: new Date().toISOString()
  };

  // Upload using provider abstraction
  state.ipfsCid = await state.storageProvider.upload(data);

  console.log('‚úÖ Uploaded to IPFS, CID:', state.ipfsCid);

  // Save CID to localStorage
  // ...
}
```

**Download Logic (simplified):**
```javascript
async function loadData() {
  if (!state.ipfsCid) {
    state.items = [];
    return;
  }

  // Download using provider abstraction
  const data = await state.storageProvider.download(state.ipfsCid);
  state.items = data.items || [];
}
```

---

### 5. `renew-presigned-url.html` (Optional)
**Status:** Can be deleted entirely
**Reason:** Pinata JWT doesn't expire hourly like presigned URLs

---

## Implementation Order

1. ‚úÖ Create branch `feat/pinata-sovereign-storage`
2. ‚úÖ Write this migration plan (with provider abstraction design)
3. ‚è≥ Update SDK - Remove S3/AWS code
4. ‚è≥ Update SDK - Add provider abstraction (IPFSProvider base class)
5. ‚è≥ Update SDK - Implement PinataProvider (reference implementation)
6. ‚è≥ Update SDK - Add createProvider() factory function
7. ‚è≥ Update demo.html - Add provider selection UI
8. ‚è≥ Update demo.html - Store provider config encrypted in IndexedDB
9. ‚è≥ Update grant.html - Pass provider config instead of presigned URLs
10. ‚è≥ Update simple-service.html - Use provider abstraction
11. ‚è≥ Test end-to-end flow with real Pinata credentials
12. ‚è≥ Clean up: Remove unused files (renew-presigned-url.html, netlify/functions/*)
13. ‚è≥ Update README with Pinata setup instructions
14. ‚è≥ Commit and create PR

---

## Testing Checklist

### Setup
- [ ] User signs up for free Pinata account at https://app.pinata.cloud
- [ ] User creates API key with upload permissions
- [ ] User configures JWT in demo.html

### Flow Testing
- [ ] Open demo.html, configure Pinata JWT, verify it saves
- [ ] Open simple-service.html, click "Connect with LocalPod"
- [ ] Grant.html receives Pinata JWT from pod
- [ ] Create a post in simple-service.html
- [ ] Verify upload to Pinata succeeds, CID returned
- [ ] Refresh page, verify post loads from IPFS via Pinata gateway
- [ ] Clear localStorage, verify CID recovery still works (or graceful empty state)

### Edge Cases
- [ ] No Pinata JWT configured - should show error message
- [ ] Invalid Pinata JWT - should show authentication error
- [ ] Network error during upload - should show retry option
- [ ] CID not found on gateway - should handle gracefully

---

## Migration Benefits Summary

### Security
‚úÖ No AWS secret keys in codebase
‚úÖ Each user controls their own credentials
‚úÖ JWT scoped to user's Pinata account

### Sovereignty
‚úÖ Users bring their own storage provider
‚úÖ Can switch providers (CIDs are portable)
‚úÖ European users can choose EU-based IPFS services

### Simplicity
‚úÖ Remove complex AWS Signature V4 code
‚úÖ No presigned URL expiration/renewal logic
‚úÖ Simple REST API calls

### Decentralization
‚úÖ Data stored on IPFS (content-addressed)
‚úÖ CIDs work on any IPFS gateway
‚úÖ Aligns with European tech independence vision

---

## Risks & Mitigations

### Risk 1: Users don't want to create Pinata accounts
**Mitigation:** Provide clear onboarding, explain sovereignty benefits

### Risk 2: Pinata free tier limits (1GB storage, 3GB bandwidth/month)
**Mitigation:** Document limits, allow users to upgrade or switch providers

### Risk 3: JWT exposure in browser
**Mitigation:** Store encrypted in IndexedDB, never log in console

### Risk 4: Pinata service outage
**Mitigation:** CIDs are portable, users can retrieve from other gateways

---

## Future Enhancements

- ‚úÖ Provider abstraction layer (included in Phase 1)
- Add European providers: Scaleway Labs, 4everland, Temporal
- Support IPFS Desktop node as provider option
- Add CID pinning verification UI
- Add storage usage dashboard
- Provider health monitoring
- Automatic failover between providers

---

## How to Add New Providers (Future)

When APIs become available for Scaleway, 4everland, or Temporal, adding them is straightforward:

### Step 1: Create Provider Class
```javascript
// sdk/providers/scaleway.js
class ScalewayProvider extends IPFSProvider {
  constructor(config) {
    super(config);
    this.apiKey = config.apiKey;
    this.region = config.region || 'fr-par';
  }

  async upload(jsonData) {
    // Implement Scaleway-specific upload
  }

  async download(cid) {
    // Implement Scaleway-specific download
  }

  getGatewayUrl(cid) {
    return `https://ipfs.scaleway.com/ipfs/${cid}`;
  }
}
```

### Step 2: Register in Factory
```javascript
// sdk/index.js
function createProvider(providerName, config) {
  switch (providerName) {
    case 'pinata':
      return new PinataProvider(config);
    case 'scaleway':
      return new ScalewayProvider(config);  // NEW
    default:
      throw new Error(`Unknown provider: ${providerName}`);
  }
}
```

### Step 3: Add to UI
```html
<!-- demo.html -->
<select id="ipfs-provider">
  <option value="pinata">Pinata</option>
  <option value="scaleway">Scaleway Labs (France)</option>  <!-- NEW -->
</select>
```

**That's it!** The rest of the code (grant.html, simple-service.html) works unchanged due to the abstraction layer.

---

## Target European Providers

### Scaleway Labs (France)
- **Status:** Available (Labs product)
- **API:** CLI-based, needs REST API investigation
- **Sovereignty:** üá´üá∑ French company, European data centers
- **Tier:** Pricing TBD

### 4everland
- **Status:** Available
- **API:** Compatible with IPFS Pinning Service API
- **Sovereignty:** Decentralized network
- **Tier:** Free tier available

### Temporal (TemporalX)
- **Status:** Available
- **API:** Full REST API
- **Sovereignty:** Enterprise-focused
- **Tier:** Paid plans

---

**Next Steps:** Review this plan, then proceed with SDK updates (step 3)
